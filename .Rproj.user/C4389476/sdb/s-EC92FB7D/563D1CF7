{
    "contents" : "#' @title spEMD\n#' @aliases spEMD\n#'\n#' @description 2D EMD for spatial objects\n#' @author Pierre Roudier\n#'\n#' @param data .\n#' @param zcol .\n#' @param method .\n#' @param n.imf.max .\n#' @param n.sp.max .\n#' @param n.extrema.min .\n#' @param stoprule .\n#' @param stoprule.extrema .\n#' @param thresh.extrema .\n#' @param tol .\n#' @param diff.nb.extrema\n#' @param abs.nb.extrema .\n#' @param nb.nn .\n#' @param n.pts.spline .\n#' @param neig .\n#' @param save_neig .\n#' @param file .\n#' @param verbose .\n#'\n#' @return .\n#'\n#' @examples\n#'\n#' # Getting sample data from the gstat package\n#' if (require(gstat)) {\n#' library(sp)\n#'\n#' # Example for gridded data\n#' data(ncp.grid, package = 'gstat')\n#' coordinates(ncp.grid) <- ~x+y\n#' gridded(ncp.grid) <- TRUE\n#' res.ncp <- spEMD(ncp.grid, zcol = \"depth\", thresh.extrema = 0.1, verbose = FALSE)\n#'\n#' # Plot results\n#' spplot(res.ncp[, c('imf1', \"imf2\", \"imf3\")])\n#' }\n#'\n#' #\n#'\n#'\n#' @include create_neig.r extrema_irr.r extract_extrema.r mean_enveloppe.r\n#'\n#' @import sp, FNN, spdep, raster\n#' @export\nspEMD <- function(\n  # DATA\n  data,\t# Input matrix at the data.frame or sp format\n  zcol=\"z\",\n  # METHOD\n  method = 'splines', # Enveloppe interpolation method\n  n.imf.max=10,\t# Maximum depth ofdecomposition (number of IMFs)\n  n.sp.max=5,\t# Number of iterations in the sifting process\n  n.extrema.min=1, # Minimum number of extrema\n  stoprule=\"mean.imf\",\n  stoprule.extrema=TRUE, # Also checks for the number of extrema to be similar\n  # THRESHOLDS\n  thresh.extrema=1, # Significative threshold for the extrema\n  tol=0, # Mean of the IMF candidate to be considered as a proper IMF\n  diff.nb.extrema=0.05, # % Limit difference maxima/minima. If smaller, more permissive on the mean of the IMF candidate\n  abs.nb.extrema=5, # Absolute difference between number of extrema\n  # PARAMETERS FOR LOCAL INTERPOLATION\n  nb.nn=4, # Number of nearest neighbours to take into account when data is on a grid\n  n.pts.spline=4,\t# number of points to locally interpolate\n  # NEIGHBOURHOOD MANAGEMENT\n  neig=NULL, # Option the re-use a formerly existing neig object in order to save time\n  save_neig=TRUE, # Option to save the neig object as a .RData file once created\n  # USER INTERACTION\n  verbose=TRUE\n){\n\n  # Make sure to work with x and y as coordinates names\n  if (all(coordnames(data) == c(\"x\",\"y\"))) {\n    change_coords_names <- FALSE\n  } else {\n    # Backup old coord names if need be\n    change_coords_names <- TRUE\n    old_coord_names <- coordnames(data)\n  }\n  # Setting coordnames to 'x' and 'y'\n  coordnames(data) <- c(\"x\",\"y\")\n\n  # testing if data is gridded\n  gridded.data <- gridded(data)\n\n  dat.to.process <- data\n\n  result <- as.data.frame(coordinates(data))\n  result[[zcol]] <- data[[zcol]]\n\n  n.imf <- 1\n  n.max.prec <- n.min.prec <- nrow(data)\n\n  # Creation of the neighbourhood description object\n  # one time for every step (only the z attribute is updated)\n  #\n  if (is.character(neig)) {\n\n    if (verbose) cat(\"Retrieving existing neighbourhood object...\\t\")\n\n    neig <- try(readRDS(neig), silent = TRUE)\n\n    if (any(class(neig) == \"try-error\")) stop(\"The neighbourhood object cannot be loaded. Wrong path to the .RData file.\")\n    # Verifications that the neig object is correct\n    if (!any(class(neig) != \"neig\")) stop(\"The neighbourhood object needs to be generated through the create.neig() function.\")\n\n  }\n  else {\n\n    if (verbose) cat(\"Creation of neighbourhood object...\\n\")\n\n    neig <- create.neig(\n      data.set = data,\n      nb.nn = nb.nn,\n      duplicate = 'remove',\n      # gridded.data = gridded.data,\n      verbose = FALSE\n    )\n\n    if (save_neig) {\n      if (verbose) cat(\"Saving neighbourhood object as a .RData file...\\t\")\n      saveRDS(neig, file=\".neig\")\n    }\n\n  }\n\n  if (verbose) cat('\\n')\n\n  # For each IMF\n  while (TRUE) {\n\n    if (verbose) cat(paste0('IMF #', n.imf, '\\n'))\n\n    criterion.sifting <- FALSE\n    n.curr.sp <- 1\n    input.imf <- dat.to.process\n\n    if (stoprule != \"mean.enveloppe\") best.stop.criterion <- Inf\n    else best.stop.criterion <- -Inf\n\n    # SIFTING PROCESS\n    while (TRUE) {\n\n      if (verbose) cat(paste('\\tSifting #',n.curr.sp,'\\n',sep=''))\n\n      # Identify all the local extrema\n      if (verbose) cat('\\t\\tIdentification of the regional extrema...\\n')\n\n      curr.extrema <- extrema.irr(\n        input.imf,\n        zcol = zcol,\n        gridded.data = gridded.data,\n        nb.nn = nb.nn,\n        thresh.extrema = thresh.extrema,\n        verbose = verbose,\n        neig = neig\n      )\n\n      if (verbose) cat('\\t\\tExtracting extrema...\\n')\n\n      curr.mat.extrema <- extract.extrema(\n        curr.extrema,\n        n.extrema.min = n.extrema.min\n      )\n\n      n.min <- curr.mat.extrema$nb.min\n      n.max <- curr.mat.extrema$nb.max\n\n      if (!curr.mat.extrema$monotone) {\n\n        # Interpolate the local extrema to get a mean enveloppe\n        if (verbose) cat('\\t\\tInterpolation of the enveloppe...\\n')\n\n        mean.enveloppe <- return.mean.enveloppe(\n          extrema = curr.mat.extrema$extrema,\n          donnee = input.imf,\n          method = method,\n          n.pts.spline = n.pts.spline,\n          zcol = zcol,\n          verbose = verbose\n        )\n\n        imf.candidate <- as.data.frame(coordinates(data))\n        imf.candidate[[zcol]] <- input.imf[[zcol]] - mean.enveloppe[[zcol]]\n\n        if (verbose) cat('\\t\\tChecking if the candidate is an IMF...\\n')\n        # Different ways to check if IMF : mean of the resulting signal VS mean of the enveloppe of the resulting signal (Linderhed, 2002)\n        #\n\n        if (stoprule == \"mean.enveloppe\") {\n\n          # After Linderhed, 2002 (every meanenveloppe pt is < epsilon)\n\n          stop.sifting <- all(mean.enveloppe[[zcol]] <= tol)\n          stop.criterion <- length(which(mean.enveloppe[[zcol]] <= tol))/length(mean.enveloppe[[zcol]])\n\n          # if (verbose) cat(paste(\"\\t\\t\\tThe current mean enveloppe has \",\n          #                        100*round(length(which(mean.enveloppe[[zcol]] <= tol))/length(mean.enveloppe[[zcol]]),digits=4),\n          #                        \"% of its values < \",tol,\"\\n\",sep=\"\"))\n\n        }\n\n        if (stoprule == \"mean.imf\") {\n\n          # Mean of the IMF candiate is close to zeros, and similar number of extremas\n\n          stop.sifting <- (abs(mean(imf.candidate[[zcol]])) <= tol)\n          stop.criterion <- abs(mean(imf.candidate[[zcol]]))\n\n          # if (verbose) cat(paste(\"\\t\\t\\tThe mean of the current IMF candidate is: \",\n          #                        round(abs(mean(imf.candidate[[zcol]])),digits=4),\" vs. \",tol,\"\\n\",sep=\"\"))\n\n        }\n\n        if (stoprule == \"huang\") {\n\n          # Huang's criterion\n\n          stop.sifting <- (sum((imf.candidate[[zcol]] - input.imf[[zcol]])^2/(input.imf[[zcol]])^2) < tol)\n          stop.criterion <- sum((imf.candidate[[zcol]] - input.imf[[zcol]])^2/(input.imf[[zcol]])^2)\n\n          # if (verbose) cat(paste(\"\\t\\t\\tThe IMF candidate has the following Huang criterion: \",\n          #                        sum((imf.candidate[[zcol]] - input.imf[[zcol]])^2/(input.imf[[zcol]])^2),\" vs. \",tol,\"\\n\",sep=\"\"))\n\n        }\n\n        # Also checking if number of extrema is similar\n        if (stoprule.extrema) {\n\n          pct.min <- n.min/(n.min+n.max)\n          stop.sifting <- stop.sifting && ((abs(pct.min - 0.5) <= diff.nb.extrema) || (abs(n.min-n.max) <= abs.nb.extrema))\n\n          if (verbose) cat(paste0(\"\\t\\t\\tExtrema ratio is: \", round(pct.min,digits = 4),\" vs. 0.5 +- \", diff.nb.extrema, \"\\n\"))\n\n        }\n\n        if (stop.sifting) {\n\n          if (verbose) cat('\\t\\t\\tOK, moving to next IMF\\n')\n          break\n\n        } else {\n\n          if (verbose) cat('\\t\\t\\tSifting process continues.\\n')\n          input.imf[[zcol]] <- imf.candidate[[zcol]]\n\n          # Keep result in memory in case it's the better after N sifting processes :\n          if (stoprule != \"mean.enveloppe\") {\n            if (stop.criterion < best.stop.criterion) {\n              best.stop.criterion <- stop.criterion\n              best.imf <- imf.candidate\n              id.best.imf <- n.curr.sp\n            }\n          }\n          else {\n            if (stop.criterion > best.stop.criterion) best.imf <- imf.candidate\n          }\n        }\n\n        if (n.curr.sp == n.sp.max) {\n          if (verbose) cat('\\t\\tThe maximum number of sifting operations has been reached.\\n')\n          if (verbose) cat('\\t\\tOK, moving to next IMF\\n')\n          # Check if the current IMF is the best, if not we got the former best one in memory\n          if (stoprule != \"mean.enveloppe\") {\n            if (stop.criterion < best.stop.criterion) {\n              best.imf <- imf.candidate\n              id.best.imf <- n.curr.sp\n            }\n          }\n          else {\n            if (stop.criterion > best.stop.criterion) best.imf <- imf.candidate\n          }\n          imf.candidate <- best.imf\n          if (verbose) cat(paste('\\t\\tThe best IMF was obtained on Sifting #',id.best.imf,'.\\n',sep=''))\n\n          rm(best.imf)\n          break\n        }\n\n        n.curr.sp <- n.curr.sp + 1\n      } else { # monotony\n\n        if (verbose) cat('At least one of the enveloppes is monotone. This ends the decomposition.\\n')\n        if (verbose) cat(paste('Found',n.imf-1,'IMF.\\n',sep=' '))\n        if (change_coords_names) coordnames(result) <- old_coord_names\n\n        return(result)\n      }\n    }\n\n    # Creating output of the current IMF and Residual\n    if (verbose) cat('\\t\\tUpdating IMF and residue for the next IMF...\\n')\n    result[[\"residue\"]] <- dat.to.process[[zcol]] - imf.candidate[[zcol]]\n    result[[paste(\"imf\",n.imf,sep=\"\")]] <- imf.candidate[[zcol]]\n    if (n.imf == 1) {\n      coordinates(result) <- ~x+y\n      if (gridded.data) gridded(result) <- TRUE\n    }\n    dat.to.process[[zcol]] <- result[[\"residue\"]]\n\n    # For the next iteration\n    n.min.prec <- n.min\n    n.max.prec <- n.max\n    n.imf <- n.imf + 1\n\n    if (n.imf > n.imf.max) {\n      #       if (verbose) cat('\\t\\tThe maximum number of IMF has been reached.\\n\\n')\n      #       if (verbose) cat(paste('Found',n.imf-1,'IMF.\\n',sep=' '))\n      cat('\\t\\tThe maximum number of IMF has been reached.\\n\\n')\n      cat(paste('Found',n.imf-1,'IMF.\\n',sep=' '))\n      if (change_coords_names) coordnames(result) <- old_coord_names\n      return(result)\n    }\n  }\n\n  return(result)\n}\n",
    "created" : 1487124419966.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2465840094",
    "id" : "563D1CF7",
    "lastKnownWriteTime" : 1487127264,
    "path" : "~/Script/R/spemd2/spemd/R/spemd.r",
    "project_path" : "R/spemd.r",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "type" : "r_source"
}